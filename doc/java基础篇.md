## JAVA基础

##  1. final 在 Java 中作用
	final 修饰的类叫最终类，该类不能被继承。
	final 修饰的方法不能被重写。
	final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。

## 2. Java 中的 Math.round(-1.5) 等于多少
	等于 -1，Math.round 四舍五入大于 0.5 向上取整的

## 3. String 属于基础的数据类型吗？
	String 不属于基础类型，基础类型有 8 种：byte、boolean、char、short、int、float、long、double，而 String 是引用类型.

	java 中基础类型与引用类型的区别是：
	基础类型只表示简单的字符或数字，仅表示简单的数据类型；
	引用类型可以是任何复杂的数据结构 可以表示复杂的数据类型，还可以操作这种数据类型的行为 

	java虚拟机处理基础类型与引用类型的方式是不一样的，
	对于基本类型，java虚拟机会为其分配数据类型实际占用的内存空间，而对于引用类型变量，他仅仅是一个指向堆区中某个实例的指针。

## 4. Java 中操作字符串都有哪些类？它们之间有什么区别？
	操作字符串的类有：String、StringBuffer、StringBuilder。

	String 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，
	每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，
	而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，
	所以在经常改变字符串内容的情况下最好不要使用 String。

	StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，
	而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，
	所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。

##  5. String str="i"与 String str=new String(“i”)一样吗？
	不一样，因为内存的分配方式不一样。
	String str="i"的方式，java 虚拟机会将其分配到常量池中；
	而 String str=new String(“i”) 则会被分到堆内存中。

## 6. 如何将字符串反转？
	使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。

	// StringBuffer reverse
	StringBuffer stringBuffer = new StringBuffer();
	stringBuffer.append("abcdefg");
	System.out.println(stringBuffer.reverse()); // gfedcba
	// StringBuilder reverse
	StringBuilder stringBuilder = new StringBuilder();
	stringBuilder.append("abcdefg");
	System.out.println(stringBuilder.reverse()); // gfedcba

## 7. String 类的常用方法都有那些？
	indexOf()：返回指定字符的索引。
	charAt()：返回指定索引处的字符。
	replace()：字符串替换。
	trim()：去除字符串两端空白。
	split()：分割字符串，返回一个分割后的字符串数组。
	getBytes()：返回字符串的 byte 类型数组。
	length()：返回字符串长度。
	toLowerCase()：将字符串转成小写字母。
	toUpperCase()：将字符串转成大写字符。
	substring()：截取字符串。
	equals()：字符串比较。

## 8. 抽象类必须要有抽象方法吗？
	抽象类可以不包括抽象方法 但是含有抽象方法的类必须是抽象类

	抽象类是指不允许被实例化的类；抽象方法是没有方法体的方法。

	1、抽象类可以不包括抽象方法，它反正不会去实例化，里面的方法是不是抽象的没有本质影响。
	2、但是含有抽象方法的类绝不能被实例化，否则执行这个方法的时候，怎么办？
	3、如果子类是非抽象的，那么它就必须实现父类中的抽象方法；
	   否则，它继承来的抽象方法仍然没有方法体，也是个抽象方法，
	   此时就与“含有抽象方法的类必须是抽象类”相矛盾了。

	抽象方法不能被声明为静态
	抽象类，抽象方法不能用private修饰
	抽象类，抽象方法不能用final修饰


## 9. 普通类和抽象类有哪些区别？
	1. 普通类可以去实例化调用；抽象类不能被实例化，因为它是存在于一种概念而不非具体。
	2. 普通类和抽象类都可以被继承，但是抽象类被继承后子类必须重写继承的方法，
	除非自类也是抽象类。

## 10. 抽象类能使用 final 修饰吗？
	抽象类需要被继承才能使用，而被final修饰的类无法被继承

	①Java抽象类是内部类时，可以被private修饰
	Java抽象类不是内部类时，不可以被private修饰

## 11. 接口和抽象类有什么区别？
	1、概念不一样。接口是对动作的抽象，抽象类是对本质的抽象。
		抽象类表示的是，这个对象是什么。接口表示的是，这个对象能做什么。
		比如，男人，女人，这两个类（如果是类的话……），他们的抽象类是人。
		人可以吃东西，狗也可以吃东西，你可以把“吃东西”定义成一个接口，
		然后让这些类去实现它。
		所以，在高级语言上，一个类只能继承一个类（抽象类）
		(正如人不可能同时是生物和非生物)，但是可以实现多个接口(吃饭接口、走路接口)。
	2、使用不一样：
 		a.抽象类 和 接口 都是用来抽象具体对象的. 但是接口的抽象级别最高
		b.抽象类可以有具体的方法 和属性,  接口只能有抽象方法和不可变常量
		c.抽象类主要用来抽象类别,接口主要用来抽象功能.
		d.抽象类中，且不包含任何实现，派生类必须覆盖它们。接口中所有方法都必须是未实现的。
 		e.接口是设计的结果 ，抽象类是重构的结果

	3、使用方向：当你关注一个事物的本质的时候，用抽象类；当你关注一个操作的时候，用接口。
		注意：抽象类的功能要远超过接口，但是，定义抽象类的代价高。
		因为高级语言来说（从实际设计上来说也是）每个类只能继承一个类。
		在这个类中，你必须继承或编写出其所有子类的所有共性。
		虽然接口在功能上会弱化许多，但是它只是针对一个动作的描述。
		而且你可以在一个类中同时实现多个接口。在设计阶段会降低难度的。

## 12. Java 中 IO 流分为几种？BIO、NIO、AIO 有什么区别？
	1. java 中 IO 流分为几种？
		•按照流的流向分，可以分为输入流和输出流；
		•按照操作单元划分，可以划分为字节流和字符流；
		•按照流的角色划分为节点流和处理流。

		Java Io流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，
		而且彼此之间存在非常紧密的联系， Java I0流的40多个类都是从如下4个
		抽象类基类中派生出来的。

		•InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。
		•OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。

	2. 字符流和字节流的区别
		字符流的由来： 因为数据编码的不同，而有了对字符进行高效操作的流对象。
		本质其实就是基于字节流读取时，去查了指定的码表。
	字节流和字符流的区别：
		读写单位不同：字节流以字节（8bit）为单位，字符流以字符为单位，
					根据码表映射字符，一次可能读多个字节。
		处理对象不同：字节流能处理所有类型的数据（如图片、avi等），
					而字符流只能处理字符类型的数据。
		字节流：一次读入或读出是8位二进制。通过字节的形式一个字节一个字节或者字节
				数组来操作文件中内容，可以操作一切文件。
		字符流：一次读入或读出是16位二进制。通过单个字符或者是字符数组的形式来操作文件的，
			   存在一定的局限性，是专门用于对文本文件操作的，默认的版本为GBK
		设备上的数据无论是图片或者视频，文字，它们都以二进制存储的。
		二进制的最终都是以一个8位为数据单元进行体现，所以计算机中的最小数据单元就是字节。
		意味着，字节流可以处理设备上的所有数据，所以字节流一样可以处理字符数据。

	 

	3. 处理流的功能主要体现在以下两个方面
		1.性能的提高
	        主要以增加缓冲的方式来提高输入输出的效率。

		2.操作的便捷
	        处理流可能提供了一系列便捷方法来一次输入和输出大批量的内容，而不是输入输出一个或者多个水滴。

	处理流可以嫁接在任何一个流之上，这就允许java采取相同的代码，透明的方式来访问不同的输入/输出设备的数据流。

	通过使用处理流，java程序就不必理会输入输出节点是磁盘， 网络还是其他的输入输出设备。程序只要将这些节点流包装成处理流，就可以使用相同的代码来读写不同输入输出设备的数据。
	 

	4. BIO,NIO,AIO 有什么区别？
	•BIO (Blocking I/O): 同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。
	在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，
	可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问
	题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，
	当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，
	我们需要一种更高效的 I/O 处理模型来应对更高的并发量。

	•NIO (New I/O): NIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了NIO框架，对应
	java.nio 包，提供了 Channel , Selector，Buffer等抽象。NIO中的N可以理解为
	Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。
	NIO提供了与传统BIO模型中的 Socket 和 ServerSocket 相对应
	的 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现,
	两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，
	但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，
	可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，
	应使用 NIO 的非阻塞模式来开发

	•AIO (Asynchronous I/O): AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版
	NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作
	之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。
	AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，
	但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，
	得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。查阅网上相关资料，
	我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。


## 13. Files的常用方法都有哪些？
	Files.exists()：检测文件路径是否存在。
	Files.createFile()：创建文件。
	Files.createDirectory()：创建文件夹。
	Files.delete()：删除一个文件或目录。
	Files.copy()：复制文件。
	Files.move()：移动文件。
	Files.size()：查看文件个数。
	Files.read()：读取文件。
	Files.write()：写入文件。
